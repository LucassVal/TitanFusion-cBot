using System;
using System.Collections.Generic;
using System.Linq;
using cAlgo.API;
using cAlgo.API.Indicators;
using cAlgo.API.Internals;

namespace cAlgo.Robots
{
    public enum TitanMAType { Simple, Exponential, Weighted }

    // üéÆ STRATEGY MODES FOR TESTING & EXECUTION
    public enum StrategyMode 
    { 
        All,             // Run Everything (Risk Adjusted)
        ScalperOnly,     // Test Phase 1
        BreakoutOnly,    // Test Phase 2
        PullbackOnly,    // Test Phase 3
        ScalperBreakout, // Test Phase 4
        ScalperPullback, // Test Phase 5
        BreakoutPullback // Test Phase 6
    }

    [Robot(TimeZone = TimeZones.UTC, AccessRights = AccessRights.None)]
    public class TitanFusion_v3_3 : Robot // ATUALIZADO PARA v3.3
    {
        // =============================================================================
        // 0. STRATEGY CONTROLLER
        // =============================================================================
        #region 0. Strategy Controller
        [Parameter("üéÆ Operation Mode", Group = "0. Strategy Controller", DefaultValue = StrategyMode.ScalperOnly, Description = "Select which strategies to run.")]
        public StrategyMode CurrentMode { get; set; }
        #endregion

        // =============================================================================
        // 1. MONEY & RISK MANAGEMENT (XAUUSD OPTIMIZED)
        // =============================================================================
        #region 1. Money & Risk Management
        [Parameter("üí∞ Use Auto-Compound?", Group = "1. Money Management", DefaultValue = true)]
        public bool EnableAutoCompound { get; set; }

        [Parameter("üìä Risk % Per Trade", Group = "1. Money Management", DefaultValue = 1.5, MinValue = 0.1, Step = 0.1)]
        public double RiskPerTrade { get; set; }

        [Parameter("üõë Max Daily Drawdown (%)", Group = "1. Money Management", DefaultValue = 15, MinValue = 1)]
        public double DailyStopPercent { get; set; }

        [Parameter("üéØ Daily Target (%)", Group = "1. Money Management", DefaultValue = 8, MinValue = 1)]
        public double DailyTargetPercent { get; set; }

        [Parameter("üõ°Ô∏è Enable Profit Shield?", Group = "1. Money Management", DefaultValue = true)]
        public bool EnableProfitShield { get; set; }
        #endregion

        // =============================================================================
        // 2. SMART EXITS
        // =============================================================================
        #region 2. Smart Exits
        [Parameter("üèÉ Enable Trailing SAR?", Group = "2. Smart Exits", DefaultValue = true)]
        public bool TrailingSarEnabled { get; set; }

        [Parameter("SAR Min AF", Group = "2. Smart Exits", DefaultValue = 0.02)]
        public double SarMinAF { get; set; }

        [Parameter("SAR Max AF", Group = "2. Smart Exits", DefaultValue = 0.2)]
        public double SarMaxAF { get; set; }

        [Parameter("üîí Enable Partial TP?", Group = "2. Smart Exits", DefaultValue = true)]
        public bool PartialTpEnabled { get; set; }

        [Parameter("üîí Partial Trigger (ATR Multi)", Group = "2. Smart Exits", DefaultValue = 1.0)]
        public double PartialTpAtrMultiplier { get; set; }
        #endregion

        // =============================================================================
        // 3. FILTERS & VISUAL (XAUUSD OPTIMIZED)
        // =============================================================================
        #region 3. Filters & Visual
        [Parameter("üñ•Ô∏è Show Text Info?", Group = "3. Filters & Visual", DefaultValue = true)]
        public bool ShowPanel { get; set; }

        [Parameter("üåä Min Volatility (ATR Pips)", Group = "3. Filters & Visual", DefaultValue = 15.0)]
        public double MinAtrPips { get; set; }

        [Parameter("üõ°Ô∏è Max Spread (Pips)", Group = "3. Filters & Visual", DefaultValue = 8.0)]
        public double MaxSpread { get; set; }

        [Parameter("ü¶Å Enable H1 Trend Filter?", Group = "3. Filters & Visual", DefaultValue = true)]
        public bool EnableTrendFilterH1 { get; set; }
        #endregion

        // =============================================================================
        // 4. CHAOS GUARD (XAUUSD OPTIMIZED)
        // =============================================================================
        #region 4. Chaos Guard
        [Parameter("üå™Ô∏è Max Volatility (ATR Pips)", Group = "4. Chaos Guard", DefaultValue = 120.0)]
        public double MaxAtrPips { get; set; }

        [Parameter("ü¶Ä Flat Market Protection (Pips)", Group = "4. Chaos Guard", DefaultValue = 5.0)]
        public double FlatMarketPips { get; set; }
        #endregion

        // =============================================================================
        // 5. OPTIMIZATION WEIGHTS
        // =============================================================================
        #region 5. Fitness Weights
        [Parameter("üìâ Min Trades/Month", Group = "5. Fitness Weights", DefaultValue = 5)]
        public double TargetTradesPerMonth { get; set; }

        [Parameter("‚öñÔ∏è Weight: Net Profit", Group = "5. Fitness Weights", DefaultValue = 1.0)]
        public double WeightProfit { get; set; }

        [Parameter("‚öñÔ∏è Weight: Drawdown", Group = "5. Fitness Weights", DefaultValue = 0.5)]
        public double WeightDrawdown { get; set; }

        [Parameter("‚öñÔ∏è Weight: Win Rate", Group = "5. Fitness Weights", DefaultValue = 0.2)]
        public double WeightWinRate { get; set; }
        
        [Parameter("‚öñÔ∏è Weight: Sharpe", Group = "5. Fitness Weights", DefaultValue = 0.3)]
        public double WeightSharpe { get; set; }
        #endregion

        // =============================================================================
        // A. STRATEGY: SCALPER (XAUUSD OPTIMIZED)
        // =============================================================================
        #region A. Strategy: Scalper
        [Parameter("üì¶ Base Volume (Scalper)", Group = "A. Strategy: Scalper", DefaultValue = 0.01)]
        public double ScalperFixedVolume { get; set; }
        [Parameter("üìä RSI Period", Group = "A. Strategy: Scalper", DefaultValue = 14)]
        public int ScalperRSIPeriod { get; set; }
        [Parameter("üîµ Oversold Level", Group = "A. Strategy: Scalper", DefaultValue = 25)]
        public int RsiOversold { get; set; }
        [Parameter("üî¥ Overbought Level", Group = "A. Strategy: Scalper", DefaultValue = 75)]
        public int RsiOverbought { get; set; }
        [Parameter("üéØ Scalper TP (ATR Multi)", Group = "A. Strategy: Scalper", DefaultValue = 3.0)]
        public double ScalperTpAtr { get; set; } 
        [Parameter("üõë Scalper SL (ATR Multi)", Group = "A. Strategy: Scalper", DefaultValue = 2.0)] 
        public double ScalperSlAtr { get; set; }
        #endregion

        // =============================================================================
        // B. STRATEGY: BREAKOUT (XAUUSD OPTIMIZED)
        // =============================================================================
        #region B. Strategy: Breakout
        [Parameter("üì¶ Base Volume (Breakout)", Group = "B. Strategy: Breakout", DefaultValue = 0.01)]
        public double BreakoutFixedVolume { get; set; }
        [Parameter("üìä BB Period", Group = "B. Strategy: Breakout", DefaultValue = 20)]
        public int BBPeriod { get; set; }
        [Parameter("üìè BB Deviation", Group = "B. Strategy: Breakout", DefaultValue = 2.5)]
        public double BBDeviation { get; set; }
        [Parameter("‚ö†Ô∏è Max Band Width (Pips)", Group = "B. Strategy: Breakout", DefaultValue = 120.0)]
        public double BreakoutMaxBandWidth { get; set; }
        [Parameter("üïØÔ∏è Min Body Ratio (0.1 - 1.0)", Group = "B. Strategy: Breakout", DefaultValue = 0.6)]
        public double MinBodyRatio { get; set; }
        [Parameter("üéØ Breakout TP (ATR Multi)", Group = "B. Strategy: Breakout", DefaultValue = 5.0)] 
        public double BreakoutTpAtr { get; set; }
        [Parameter("üõë Breakout SL (ATR Multi)", Group = "B. Strategy: Breakout", DefaultValue = 1.5)] 
        public double BreakoutSlAtr { get; set; }
        #endregion

        // =============================================================================
        // C. STRATEGY: PULLBACK (XAUUSD OPTIMIZED)
        // =============================================================================
        #region C. Strategy: Pullback
        [Parameter("üì¶ Base Volume (Pullback)", Group = "C. Strategy: Pullback", DefaultValue = 0.01)]
        public double PullbackFixedVolume { get; set; }
        [Parameter("üìà Trend EMA Fast", Group = "C. Strategy: Pullback", DefaultValue = 34)]
        public int TrendEmaFast { get; set; }
        [Parameter("üìâ Trend EMA Slow", Group = "C. Strategy: Pullback", DefaultValue = 144)]
        public int TrendEmaSlow { get; set; }
        [Parameter("üìâ Pullback RSI Trigger", Group = "C. Strategy: Pullback", DefaultValue = 40)]
        public int PullbackRsiTrigger { get; set; }
        [Parameter("üéØ Pullback TP (ATR Multi)", Group = "C. Strategy: Pullback", DefaultValue = 4.0)]
        public double PullbackTpAtr { get; set; }
        [Parameter("üõë Pullback SL (ATR Multi)", Group = "C. Strategy: Pullback", DefaultValue = 1.5)]
        public double PullbackSlAtr { get; set; }
        #endregion

        // INDICATORS
        private RelativeStrengthIndex _rsiScalper;
        private RelativeStrengthIndex _rsiPullback;
        private MovingAverage _trendEmaFast; 
        private MovingAverage _trendEmaSlow; 
        private BollingerBands _bollingerBands;
        private ParabolicSAR _parabolicSAR;
        private AverageTrueRange _atr;
        private MovingAverage _emaH1Fast;
        private MovingAverage _emaH1Slow;

        // STATE
        private double _initialBalance;
        private DateTime _startTime;
        private List<string> _partiallyClosedPositions = new List<string>();
        private int _totalTradesCount = 0;

        // TIME CONSTANTS (XAUUSD OPTIMIZED)
        private const int FIXED_START_HOUR = 7;   // London Open
        private const int FIXED_END_HOUR = 20;    // NY Close

        protected override void OnStart()
        {
            _initialBalance = Account.Balance;
            _startTime = Server.Time;
            InitializeIndicators();
            Positions.Closed += OnPositionClosed;
            Positions.Opened += OnPositionOpened;
            
            Print($"Titan Fusion v3.3 Started - Mode: {CurrentMode}"); // ATUALIZADO
            Print($"Symbol: {SymbolName}, Timeframe: {TimeFrame}");
            Print($"XAUUSD Optimized - ATR Range: {MinAtrPips}-{MaxAtrPips} pips");
        }

        private void InitializeIndicators()
        {
            _atr = Indicators.AverageTrueRange(14, MovingAverageType.Simple);
            _rsiScalper = Indicators.RelativeStrengthIndex(Bars.ClosePrices, ScalperRSIPeriod);
            _bollingerBands = Indicators.BollingerBands(Bars.ClosePrices, BBPeriod, BBDeviation, MovingAverageType.Simple);
            _trendEmaFast = Indicators.MovingAverage(Bars.ClosePrices, TrendEmaFast, MovingAverageType.Exponential);
            _trendEmaSlow = Indicators.MovingAverage(Bars.ClosePrices, TrendEmaSlow, MovingAverageType.Exponential);
            _rsiPullback = Indicators.RelativeStrengthIndex(Bars.ClosePrices, 14);
            
            if (TrailingSarEnabled) 
                _parabolicSAR = Indicators.ParabolicSAR(SarMinAF, SarMaxAF);
            
            if (EnableTrendFilterH1)
            {
                try
                {
                    var h1Bars = MarketData.GetBars(TimeFrame.Hour, SymbolName);
                    _emaH1Fast = Indicators.MovingAverage(h1Bars.ClosePrices, 20, MovingAverageType.Exponential);
                    _emaH1Slow = Indicators.MovingAverage(h1Bars.ClosePrices, 50, MovingAverageType.Exponential);
                    Print("H1 Trend Filter initialized successfully");
                }
                catch (Exception ex)
                {
                    Print($"Warning: Could not initialize H1 Trend Filter: {ex.Message}");
                    EnableTrendFilterH1 = false;
                }
            }
        }

        protected override void OnBar()
        {
            try
            {
                // 1. EARLY STOPPING
                if (TargetTradesPerMonth > 0)
                {
                    double daysRunning = (Server.Time - _startTime).TotalDays;
                    if (daysRunning >= 30.0) 
                    {
                        double monthsRunning = daysRunning / 30.0;
                        double currentRate = _totalTradesCount / monthsRunning;
                        if (currentRate < TargetTradesPerMonth) 
                        { 
                            Print($"Early stopping: Only {currentRate:F1} trades/month");
                            Stop(); 
                            return; 
                        }
                    }
                }

                // 2. DAILY MGMT
                double dailyPL = Account.Equity - _initialBalance; 
                double targetMoney = _initialBalance * (DailyTargetPercent / 100.0);
                double lossLimit = _initialBalance * (DailyStopPercent / 100.0);
                
                if (dailyPL >= targetMoney)
                {
                    Print($"Daily target reached: +{dailyPL:F2}");
                    return;
                }
                
                if (dailyPL <= -lossLimit)
                {
                    Print($"Daily stop loss hit: {dailyPL:F2}");
                    return;
                }

                // 3. FILTERS
                if (!IsTradingAllowed()) return;
                if (IsMarketTooCrazy()) return;
                
                bool isFlat = IsMarketFlat();
                bool h1Bullish = true, h1Bearish = true;
                
                if (EnableTrendFilterH1 && _emaH1Fast != null && _emaH1Slow != null)
                {
                    double fast = _emaH1Fast.Result.Last(1);
                    double slow = _emaH1Slow.Result.Last(1);
                    h1Bullish = fast > slow;
                    h1Bearish = fast < slow;
                }

                // 4. MODE CONTROLLER (SWITCH)
                switch (CurrentMode)
                {
                    case StrategyMode.All:
                        ProcessScalperEntry(h1Bullish, h1Bearish);
                        if (!isFlat) 
                        {
                            ProcessBreakoutEntry(h1Bullish, h1Bearish);
                            ProcessPullbackEntry(h1Bullish, h1Bearish);
                        }
                        break;

                    case StrategyMode.ScalperOnly:
                        ProcessScalperEntry(h1Bullish, h1Bearish);
                        break;

                    case StrategyMode.BreakoutOnly:
                        if (!isFlat) ProcessBreakoutEntry(h1Bullish, h1Bearish);
                        break;

                    case StrategyMode.PullbackOnly:
                        if (!isFlat) ProcessPullbackEntry(h1Bullish, h1Bearish);
                        break;

                    case StrategyMode.ScalperBreakout:
                        ProcessScalperEntry(h1Bullish, h1Bearish);
                        if (!isFlat) ProcessBreakoutEntry(h1Bullish, h1Bearish);
                        break;

                    case StrategyMode.ScalperPullback:
                        ProcessScalperEntry(h1Bullish, h1Bearish);
                        if (!isFlat) ProcessPullbackEntry(h1Bullish, h1Bearish);
                        break;

                    case StrategyMode.BreakoutPullback:
                        if (!isFlat) 
                        {
                            ProcessBreakoutEntry(h1Bullish, h1Bearish);
                            ProcessPullbackEntry(h1Bullish, h1Bearish);
                        }
                        break;
                }
                
                if(ShowPanel) DrawSimpleText();
            }
            catch (Exception ex)
            {
                Print($"Error in OnBar: {ex.Message}");
            }
        }

        protected override void OnTick()
        {
            try
            {
                if (Positions.Count > 0) ManagePositions();
            }
            catch (Exception ex)
            {
                Print($"Error in OnTick: {ex.Message}");
            }
        }

        // =============================================================================
        // üî• M√âTODO ManagePositions CORRIGIDO PARA v3.3
        // =============================================================================
        private void ManagePositions()
        {
            if (_parabolicSAR == null) return;
            double sar = _parabolicSAR.Result.LastValue;
            double atr = _atr.Result.Last(1);
            double pipSize = Symbol.PipSize;

            foreach (var position in Positions.ToList()) // üî• CR√çTICO: .ToList() para evitar modifica√ß√£o da cole√ß√£o
            {
                if (position.SymbolName != SymbolName) continue;

                // 1. PARTIAL TAKE PROFIT (BLINDADO CONTRA BADVOLUME)
                if (PartialTpEnabled && !_partiallyClosedPositions.Contains(position.Id.ToString()))
                {
                    double triggerPips = (atr * PartialTpAtrMultiplier) / pipSize;
                    if (position.Pips >= triggerPips)
                    {
                        double volToClose = Symbol.NormalizeVolumeInUnits(position.VolumeInUnits * 0.5, RoundingMode.Down);
                        
                        if (volToClose >= Symbol.VolumeInUnitsMin) 
                        {
                            var closeResult = ClosePosition(position, volToClose);
                            
                            if (closeResult.IsSuccessful) 
                            {
                                Print($"üí∞ Partial TP Executed on {position.Label}");
                                _partiallyClosedPositions.Add(position.Id.ToString());
                                
                                // üö® VERIFICA√á√ÉO CR√çTICA: Volume ainda existe?
                                if (position.VolumeInUnits > 0) 
                                {
                                    double newSL = position.TradeType == TradeType.Buy ? 
                                        position.EntryPrice + (2 * pipSize) : 
                                        position.EntryPrice - (2 * pipSize);
                                    ModifyPosition(position, newSL, position.TakeProfit);
                                }
                                else 
                                {
                                    Print("Partial close became Full close. No SL move needed.");
                                }
                            }
                        } 
                        else 
                        {
                            // Volume muito pequeno para dividir
                            _partiallyClosedPositions.Add(position.Id.ToString());
                            double newSL = position.EntryPrice + (position.TradeType == TradeType.Buy ? (2 * pipSize) : -(2 * pipSize));
                            ModifyPosition(position, newSL, position.TakeProfit);
                        }
                    }
                }

                // 2. TRAILING STOP (ANTI-SPAM E FILTRO DE RU√çDO)
                if (TrailingSarEnabled && position.VolumeInUnits > 0)
                {
                    double currentSL = position.StopLoss ?? position.EntryPrice;
                    double newSL = currentSL;
                    bool update = false;

                    if (position.TradeType == TradeType.Buy) {
                        if (sar > currentSL && sar < Symbol.Bid - (2 * pipSize)) {
                            if (sar - currentSL > pipSize) { newSL = sar; update = true; }
                        }
                    } else {
                        if (sar < currentSL && sar > Symbol.Ask + (2 * pipSize)) {
                            if (currentSL - sar > pipSize) { newSL = sar; update = true; }
                        }
                    }

                    if (update) ModifyPosition(position, newSL, position.TakeProfit);
                }
            }
        }

        // =============================================================================
        // M√âTODOS DE ENTRADA DAS ESTRAT√âGIAS
        // =============================================================================

        private void ProcessScalperEntry(bool allowBuy, bool allowSell)
        {
            if (!CanOpenNewPosition("SCALPER")) return;
            
            double currentRsi = _rsiScalper.Result.Last(1);
            double prevRsi = _rsiScalper.Result.Last(2);
            double atr = _atr.Result.Last(1);
            double slPips = (atr * ScalperSlAtr) / Symbol.PipSize;
            double tpPips = (atr * ScalperTpAtr) / Symbol.PipSize;
            double vol = CalculateVolume(slPips, "SCALPER");

            if (prevRsi <= RsiOversold && currentRsi > RsiOversold && allowBuy) 
            {
                if (!HasOppositePosition(TradeType.Buy, "SCALPER")) 
                {
                    var result = ExecuteMarketOrder(TradeType.Buy, SymbolName, vol, "SCALPER", slPips, tpPips);
                    if (result.IsSuccessful) 
                        Print($"Scalper BUY - RSI: {currentRsi:F1}, Vol: {vol:F2}");
                }
            }
            else if (prevRsi >= RsiOverbought && currentRsi < RsiOverbought && allowSell) 
            {
                if (!HasOppositePosition(TradeType.Sell, "SCALPER")) 
                {
                    var result = ExecuteMarketOrder(TradeType.Sell, SymbolName, vol, "SCALPER", slPips, tpPips);
                    if (result.IsSuccessful) 
                        Print($"Scalper SELL - RSI: {currentRsi:F1}, Vol: {vol:F2}");
                }
            }
        }

        private void ProcessBreakoutEntry(bool allowBuy, bool allowSell)
        {
            if (!CanOpenNewPosition("BREAKOUT")) return;
            
            double top = _bollingerBands.Top.Last(1);
            double bottom = _bollingerBands.Bottom.Last(1);
            double close = Bars.ClosePrices.Last(1);
            double open = Bars.OpenPrices.Last(1);
            
            // Band width filter
            double bandWidth = (top - bottom) / Symbol.PipSize;
            if (bandWidth > BreakoutMaxBandWidth) return;
            
            // Candle body filter
            double totalSize = Bars.HighPrices.Last(1) - Bars.LowPrices.Last(1);
            if (totalSize > 0 && (Math.Abs(close - open) / totalSize) < MinBodyRatio) return;

            double atr = _atr.Result.Last(1);
            double slPips = (atr * BreakoutSlAtr) / Symbol.PipSize;
            double tpPips = (atr * BreakoutTpAtr) / Symbol.PipSize;
            double vol = CalculateVolume(slPips, "BREAKOUT");

            if (close > top && allowBuy) 
            {
                if (!HasOppositePosition(TradeType.Buy, "BREAKOUT")) 
                {
                    var result = ExecuteMarketOrder(TradeType.Buy, SymbolName, vol, "BREAKOUT", slPips, tpPips);
                    if (result.IsSuccessful) 
                        Print($"Breakout BUY - Above BB: {bandWidth:F1}pips, Vol: {vol:F2}");
                }
            }
            else if (close < bottom && allowSell) 
            {
                if (!HasOppositePosition(TradeType.Sell, "BREAKOUT")) 
                {
                    var result = ExecuteMarketOrder(TradeType.Sell, SymbolName, vol, "BREAKOUT", slPips, tpPips);
                    if (result.IsSuccessful) 
                        Print($"Breakout SELL - Below BB: {bandWidth:F1}pips, Vol: {vol:F2}");
                }
            }
        }
        
        private void ProcessPullbackEntry(bool allowBuy, bool allowSell)
        {
            if (!CanOpenNewPosition("PULLBACK")) return;
            
            double rsi = _rsiPullback.Result.Last(1);
            bool isUptrend = _trendEmaFast.Result.Last(1) > _trendEmaSlow.Result.Last(1);
            bool isDowntrend = _trendEmaFast.Result.Last(1) < _trendEmaSlow.Result.Last(1);
            double atr = _atr.Result.Last(1);
            double slPips = (atr * PullbackSlAtr) / Symbol.PipSize;
            double tpPips = (atr * PullbackTpAtr) / Symbol.PipSize;
            double vol = CalculateVolume(slPips, "PULLBACK");

            if (isUptrend && rsi < PullbackRsiTrigger && allowBuy) 
            {
                if (!HasOppositePosition(TradeType.Buy, "PULLBACK")) 
                {
                    var result = ExecuteMarketOrder(TradeType.Buy, SymbolName, vol, "PULLBACK", slPips, tpPips);
                    if (result.IsSuccessful) 
                        Print($"Pullback BUY - Trend: UP, RSI: {rsi:F1}, Vol: {vol:F2}");
                }
            }
            else if (isDowntrend && rsi > (100 - PullbackRsiTrigger) && allowSell) 
            {
                if (!HasOppositePosition(TradeType.Sell, "PULLBACK")) 
                {
                    var result = ExecuteMarketOrder(TradeType.Sell, SymbolName, vol, "PULLBACK", slPips, tpPips);
                    if (result.IsSuccessful) 
                        Print($"Pullback SELL - Trend: DOWN, RSI: {rsi:F1}, Vol: {vol:F2}");
                }
            }
        }

        // =============================================================================
        // M√âTODOS AUXILIARES (COMPLETOS)
        // =============================================================================

        private double CalculateVolume(double stopLossPips, string strategy)
        {
            if (stopLossPips <= 0) stopLossPips = 15;
            if (!EnableAutoCompound) return Symbol.QuantityToVolumeInUnits(GetFixedVolume(strategy));
            
            double stratMultiplier = strategy switch { "SCALPER" => 0.8, "BREAKOUT" => 1.0, "PULLBACK" => 1.2, _ => 1.0 };
            
            double systemDampener = CurrentMode switch
            {
                StrategyMode.All => 0.6,
                StrategyMode.ScalperBreakout => 0.8,
                StrategyMode.ScalperPullback => 0.8,
                StrategyMode.BreakoutPullback => 0.8,
                _ => 1.0
            };

            double finalRisk = RiskPerTrade * stratMultiplier * systemDampener;
            double riskAmount = Account.Balance * (finalRisk / 100.0);
            
            double pipValue = Symbol.PipValue;
            if (pipValue == 0) pipValue = Symbol.TickValue; 
            
            double volumeInUnits = riskAmount / (stopLossPips * pipValue);
            
            double normalizedVolume = Symbol.NormalizeVolumeInUnits(volumeInUnits, RoundingMode.Down);
            double minVolume = Symbol.VolumeInUnitsMin;
            double maxVolume = Symbol.VolumeInUnitsMax * 0.1; 
            
            if (normalizedVolume < minVolume) return minVolume;
            if (normalizedVolume > maxVolume) return maxVolume;
            return normalizedVolume;
        }

        private double GetFixedVolume(string strategy)
        {
            return strategy switch
            {
                "SCALPER" => ScalperFixedVolume,
                "BREAKOUT" => BreakoutFixedVolume,
                "PULLBACK" => PullbackFixedVolume,
                _ => 0.01
            };
        }

        private bool HasOppositePosition(TradeType direction, string label)
        {
            var oppositeType = direction == TradeType.Buy ? TradeType.Sell : TradeType.Buy;
            return Positions.Any(p => 
                p.SymbolName == SymbolName && 
                p.TradeType == oppositeType && 
                p.Label == label);
        }

        private bool CanOpenNewPosition(string strategy)
        {
            if (Positions.Count(p => p.Label == strategy) >= 1) return false;
            if (Positions.Count >= 3) return false;
            return true;
        }

        private bool IsTradingAllowed()
        {
            int currentHour = Server.Time.Hour;
            if (currentHour < FIXED_START_HOUR || currentHour >= FIXED_END_HOUR) 
                return false;
                
            double currentAtr = _atr.Result.Last(1) / Symbol.PipSize;
            if (currentAtr < MinAtrPips) 
                return false;
                
            double currentSpread = Symbol.Spread / Symbol.PipSize;
            if (currentSpread > MaxSpread) 
                return false;
                
            return true;
        }

        private bool IsMarketTooCrazy() 
        { 
            return (_atr.Result.Last(1) / Symbol.PipSize) > MaxAtrPips; 
        }

        private bool IsMarketFlat()
        {
            double fast = _trendEmaFast.Result.Last(1);
            double slow = _trendEmaSlow.Result.Last(1);
            return (Math.Abs(fast - slow) / Symbol.PipSize) < FlatMarketPips;
        }

        private void DrawSimpleText()
        {
            string mode = CurrentMode.ToString();
            double equity = Account.Equity;
            double balance = Account.Balance;
            double pl = equity - balance;
            double atrPips = _atr.Result.Last(1) / Symbol.PipSize;
            int positions = Positions.Count;
            
            string text = $"TITAN v3.3 | Mode: {mode} | P/L: {pl:F2} | Pos: {positions} | ATR: {atrPips:F1}p"; // ATUALIZADO
            Chart.DrawStaticText("simple_info", text, VerticalAlignment.Top, HorizontalAlignment.Left, 
                               pl >= 0 ? Color.Lime : Color.Orange);
        }

        // =============================================================================
        // EVENT HANDLERS
        // =============================================================================

        private void OnPositionOpened(PositionOpenedEventArgs args) 
        { 
            _totalTradesCount++;
            Print($"Position opened: {args.Position.Label} - {args.Position.TradeType} {args.Position.VolumeInUnits:F2} units");
        }

        private void OnPositionClosed(PositionClosedEventArgs args)
        {
            if (_partiallyClosedPositions.Contains(args.Position.Id.ToString())) 
                _partiallyClosedPositions.Remove(args.Position.Id.ToString());
                
            Print($"Position closed: {args.Position.Label} - P/L: {args.Position.NetProfit:F2}");
        }

        protected override double GetFitness(GetFitnessArgs args)
        {
            double netProfit = args.NetProfit;
            double winRate = args.WinningTrades / (args.TotalTrades + 1.0);
            double drawdown = args.MaxEquityDrawdown;
            double sharpe = args.SharpeRatio;

            double score = (netProfit * 1.0) 
                         - (drawdown * 0.5 * 5.0) 
                         + (winRate * 0.2 * 1000) 
                         + (sharpe * 0.3 * 100);
            return score;
        }

        protected override void OnStop()
        {
            Print($"Titan Fusion v3.3 stopped. Total trades: {_totalTradesCount}"); // ATUALIZADO
            Print($"Final Equity: {Account.Equity:F2}, Balance: {Account.Balance:F2}");
        }
    }
}
