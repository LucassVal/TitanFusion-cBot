using System;
using System.Collections.Generic;
using System.Linq;
using cAlgo.API;
using cAlgo.API.Indicators;
using cAlgo.API.Internals;

namespace cAlgo.Robots
{
    public enum TitanMAType { Simple, Exponential, Weighted }

    // ğŸ® STRATEGY MODES FOR TESTING & EXECUTION
    public enum StrategyMode 
    { 
        All,             // ğŸ¯ Run Everything (Risk Adjusted)
        ScalperOnly,     // âš¡ Test Phase 1
        BreakoutOnly,    // ğŸ’¥ Test Phase 2  
        PullbackOnly,    // ğŸŒŠ Test Phase 3
        ScalperBreakout, // âš¡ğŸ’¥ Test Phase 4
        ScalperPullback, // âš¡ğŸŒŠ Test Phase 5
        BreakoutPullback // ğŸ’¥ğŸŒŠ Test Phase 6
    }

    [Robot(TimeZone = TimeZones.UTC, AccessRights = AccessRights.None)]
    public class TitanFusion : Robot
    {
        // =============================================================================
        // ğŸ›ï¸ PARAMETERS
        // =============================================================================
        #region Parameters
        [Parameter("ğŸ® Operation Mode", Group = "0. Strategy Controller", DefaultValue = StrategyMode.ScalperOnly)]
        public StrategyMode CurrentMode { get; set; }
        
        [Parameter("ğŸ’° Use Auto-Compound?", Group = "1. Money Management", DefaultValue = true)]
        public bool EnableAutoCompound { get; set; }
        
        [Parameter("ğŸ“Š Risk % Per Trade", Group = "1. Money Management", DefaultValue = 1.5)]
        public double RiskPerTrade { get; set; }
        
        [Parameter("ğŸ›‘ Max Daily Drawdown (%)", Group = "1. Money Management", DefaultValue = 15)]
        public double DailyStopPercent { get; set; }
        
        [Parameter("ğŸ¯ Daily Target (%)", Group = "1. Money Management", DefaultValue = 8)]
        public double DailyTargetPercent { get; set; }
        
        [Parameter("ğŸ›¡ï¸ Enable Profit Shield?", Group = "1. Money Management", DefaultValue = true)]
        public bool EnableProfitShield { get; set; }
        
        [Parameter("ğŸƒ Enable Trailing SAR?", Group = "2. Smart Exits", DefaultValue = true)]
        public bool TrailingSarEnabled { get; set; }
        
        [Parameter("ğŸ“ˆ SAR Min AF", Group = "2. Smart Exits", DefaultValue = 0.02)]
        public double SarMinAF { get; set; }
        
        [Parameter("ğŸ“‰ SAR Max AF", Group = "2. Smart Exits", DefaultValue = 0.2)]
        public double SarMaxAF { get; set; }
        
        [Parameter("ğŸ”’ Enable Partial TP?", Group = "2. Smart Exits", DefaultValue = true)]
        public bool PartialTpEnabled { get; set; }
        
        [Parameter("ğŸ¯ Partial Trigger (ATR Multi)", Group = "2. Smart Exits", DefaultValue = 1.0)]
        public double PartialTpAtrMultiplier { get; set; }
        
        [Parameter("ğŸ–¥ï¸ Show Text Info?", Group = "3. Filters & Visual", DefaultValue = true)]
        public bool ShowPanel { get; set; }
        
        [Parameter("ğŸŒŠ Min Volatility (ATR Pips)", Group = "3. Filters & Visual", DefaultValue = 2.0)]
        public double MinAtrPips { get; set; }
        
        [Parameter("ğŸ›¡ï¸ Max Spread (Pips)", Group = "3. Filters & Visual", DefaultValue = 10.0)]
        public double MaxSpread { get; set; }
        
        [Parameter("ğŸ¦ Enable H1 Trend Filter?", Group = "3. Filters & Visual", DefaultValue = false)]
        public bool EnableTrendFilterH1 { get; set; }
        
        [Parameter("ğŸŒªï¸ Max Volatility (ATR Pips)", Group = "4. Chaos Guard", DefaultValue = 500.0)]
        public double MaxAtrPips { get; set; }
        
        [Parameter("ğŸ¦€ Flat Market Protection (Pips)", Group = "4. Chaos Guard", DefaultValue = 2.0)]
        public double FlatMarketPips { get; set; }
        
        [Parameter("ğŸ“‰ Min Trades/Month", Group = "5. Fitness Weights", DefaultValue = 5)]
        public double TargetTradesPerMonth { get; set; }

        [Parameter("ğŸ“¦ Base Volume (Scalper)", Group = "âš¡ Scalper", DefaultValue = 0.01)]
        public double ScalperFixedVolume { get; set; }
        
        [Parameter("ğŸ“Š RSI Period", Group = "âš¡ Scalper", DefaultValue = 14)]
        public int ScalperRSIPeriod { get; set; }
        
        [Parameter("ğŸ”µ Oversold Level", Group = "âš¡ Scalper", DefaultValue = 30)]
        public int RsiOversold { get; set; }
        
        [Parameter("ğŸ”´ Overbought Level", Group = "âš¡ Scalper", DefaultValue = 70)]
        public int RsiOverbought { get; set; }
        
        [Parameter("ğŸ¯ Scalper TP ATR", Group = "âš¡ Scalper", DefaultValue = 3.0)]
        public double ScalperTpAtr { get; set; }
        
        [Parameter("ğŸ›‘ Scalper SL ATR", Group = "âš¡ Scalper", DefaultValue = 2.0)]
        public double ScalperSlAtr { get; set; }

        [Parameter("ğŸ“¦ Base Volume (Breakout)", Group = "ğŸ’¥ Breakout", DefaultValue = 0.01)]
        public double BreakoutFixedVolume { get; set; }
        
        [Parameter("ğŸ“Š BB Period", Group = "ğŸ’¥ Breakout", DefaultValue = 20)]
        public int BBPeriod { get; set; }
        
        [Parameter("ğŸ“ BB Deviation", Group = "ğŸ’¥ Breakout", DefaultValue = 2.0)]
        public double BBDeviation { get; set; }
        
        [Parameter("âš ï¸ Max Band Width", Group = "ğŸ’¥ Breakout", DefaultValue = 500.0)]
        public double BreakoutMaxBandWidth { get; set; }
        
        [Parameter("ğŸ•¯ï¸ Min Body Ratio", Group = "ğŸ’¥ Breakout", DefaultValue = 0.5)]
        public double MinBodyRatio { get; set; }
        
        [Parameter("ğŸ¯ Breakout TP ATR", Group = "ğŸ’¥ Breakout", DefaultValue = 5.0)]
        public double BreakoutTpAtr { get; set; }
        
        [Parameter("ğŸ›‘ Breakout SL ATR", Group = "ğŸ’¥ Breakout", DefaultValue = 1.5)]
        public double BreakoutSlAtr { get; set; }

        [Parameter("ğŸ“¦ Base Volume (Pullback)", Group = "ğŸŒŠ Pullback", DefaultValue = 0.01)]
        public double PullbackFixedVolume { get; set; }
        
        [Parameter("ğŸ“ˆ Trend EMA Fast", Group = "ğŸŒŠ Pullback", DefaultValue = 34)]
        public int TrendEmaFast { get; set; }
        
        [Parameter("ğŸ“‰ Trend EMA Slow", Group = "ğŸŒŠ Pullback", DefaultValue = 144)]
        public int TrendEmaSlow { get; set; }
        
        [Parameter("ğŸ“‰ Pullback RSI Trigger", Group = "ğŸŒŠ Pullback", DefaultValue = 40)]
        public int PullbackRsiTrigger { get; set; }
        
        [Parameter("ğŸ¯ Pullback TP ATR", Group = "ğŸŒŠ Pullback", DefaultValue = 4.0)]
        public double PullbackTpAtr { get; set; }
        
        [Parameter("ğŸ›‘ Pullback SL ATR", Group = "ğŸŒŠ Pullback", DefaultValue = 1.5)]
        public double PullbackSlAtr { get; set; }
        #endregion

        // ğŸ“Š INDICATORS
        private RelativeStrengthIndex _rsiScalper, _rsiPullback;
        private MovingAverage _trendEmaFast, _trendEmaSlow, _emaH1Fast, _emaH1Slow;
        private BollingerBands _bollingerBands;
        private ParabolicSAR _parabolicSAR;
        private AverageTrueRange _atr;
        
        // ğŸ’¾ STATE
        private double _initialBalance;
        private DateTime _startTime;
        private List<string> _partiallyClosedPositions = new List<string>();
        private int _totalTradesCount = 0;
        private const int FIXED_START_HOUR = 7, FIXED_END_HOUR = 20;

        protected override void OnStart()
        {
            _initialBalance = Account.Balance;
            _startTime = Server.Time;
            InitializeIndicators();
            Positions.Closed += OnPositionClosed;
            Positions.Opened += OnPositionOpened;
            
            Print($"ğŸš€ Titan Fusion Started - Mode: {CurrentMode}");
            Print($"ğŸ“Š Symbol: {SymbolName}, Timeframe: {TimeFrame}");
            Print($"ğŸ’° Initial Balance: {_initialBalance:F2}");
            Print($"âš¡ XAUUSD Optimized | ATR Range: {MinAtrPips}-{MaxAtrPips} pips");
            Print($"ğŸ¦ H1 Trend Filter: {(EnableTrendFilterH1 ? "âœ… ENABLED" : "âŒ DISABLED")}");
        }

        private void InitializeIndicators()
        {
            try
            {
                _atr = Indicators.AverageTrueRange(14, MovingAverageType.Simple);
                _rsiScalper = Indicators.RelativeStrengthIndex(Bars.ClosePrices, ScalperRSIPeriod);
                _bollingerBands = Indicators.BollingerBands(Bars.ClosePrices, BBPeriod, BBDeviation, MovingAverageType.Simple);
                _trendEmaFast = Indicators.MovingAverage(Bars.ClosePrices, TrendEmaFast, MovingAverageType.Exponential);
                _trendEmaSlow = Indicators.MovingAverage(Bars.ClosePrices, TrendEmaSlow, MovingAverageType.Exponential);
                _rsiPullback = Indicators.RelativeStrengthIndex(Bars.ClosePrices, 14);
                
                if (TrailingSarEnabled) 
                    _parabolicSAR = Indicators.ParabolicSAR(SarMinAF, SarMaxAF);
                
                if (EnableTrendFilterH1)
                {
                    try 
                    {
                        var h1Bars = MarketData.GetBars(TimeFrame.Hour, SymbolName);
                        if (h1Bars.Count >= 100)
                        {
                            _emaH1Fast = Indicators.MovingAverage(h1Bars.ClosePrices, 20, MovingAverageType.Exponential);
                            _emaH1Slow = Indicators.MovingAverage(h1Bars.ClosePrices, 50, MovingAverageType.Exponential);
                            Print($"âœ… H1 Trend Filter Initialized | Bars: {h1Bars.Count}");
                        }
                        else
                        {
                            Print($"âš ï¸ Insufficient H1 Data ({h1Bars.Count} bars) | Disabling H1 Filter");
                            EnableTrendFilterH1 = false;
                        }
                    }
                    catch (Exception ex)
                    {
                        Print($"âŒ H1 Filter Failed: {ex.Message}");
                        Print($"ğŸ”„ Auto-Fallback: H1 Filter Disabled");
                        EnableTrendFilterH1 = false;
                    }
                }
                
                Print($"ğŸ“ˆ Indicators Ready | ATR: {_atr.Result.LastValue:F4}");
            }
            catch (Exception ex)
            {
                Print($"ğŸ’¥ CRITICAL: Indicator Init Failed: {ex.Message}");
                Print($"ğŸ›‘ Emergency Stop - Restart Required");
                Stop();
            }
        }

        protected override void OnBar()
        {
            try
            {
                // â¹ï¸ EARLY STOPPING
                if (TargetTradesPerMonth > 0)
                {
                    double daysRunning = (Server.Time - _startTime).TotalDays;
                    if (daysRunning >= 30.0) 
                    {
                        double monthsRunning = daysRunning / 30.0;
                        double currentRate = _totalTradesCount / monthsRunning;
                        if (currentRate < TargetTradesPerMonth) 
                        { 
                            Print($"â¹ï¸ Early Stopping | Only {currentRate:F1} trades/month");
                            Stop(); 
                            return; 
                        }
                    }
                }

                // ğŸ’° DAILY MANAGEMENT
                double dailyPL = Account.Equity - _initialBalance; 
                double targetMoney = _initialBalance * (DailyTargetPercent / 100.0);
                double lossLimit = _initialBalance * (DailyStopPercent / 100.0);
                
                if (dailyPL >= targetMoney)
                {
                    Print($"ğŸ¯ Daily Target Reached: +{dailyPL:F2}");
                    return;
                }
                
                if (dailyPL <= -lossLimit)
                {
                    Print($"ğŸ›‘ Daily Stop Loss Hit: {dailyPL:F2}");
                    Stop();
                    return;
                }

                // ğŸ›ï¸ FILTERS
                if (!IsTradingAllowed()) 
                {
                    Print($"â¸ï¸ Trading Paused | Outside Hours or Bad Conditions");
                    return;
                }
                
                if (IsMarketTooCrazy()) 
                {
                    Print($"ğŸŒªï¸ Market Too Volatile | ATR: {_atr.Result.Last(1) / Symbol.PipSize:F1}pips");
                    return;
                }
                
                bool isFlat = IsMarketFlat();
                bool h1Bullish = true, h1Bearish = true;
                
                if (EnableTrendFilterH1 && _emaH1Fast != null && _emaH1Slow != null)
                {
                    try
                    {
                        double fast = _emaH1Fast.Result.Last(1);
                        double slow = _emaH1Slow.Result.Last(1);
                        h1Bullish = fast > slow;
                        h1Bearish = fast < slow;
                        Print($"ğŸ“Š H1 Trend: {(h1Bullish ? "ğŸŸ¢ BULLISH" : h1Bearish ? "ğŸ”´ BEARISH" : "âšª NEUTRAL")}");
                    }
                    catch (Exception ex)
                    {
                        Print($"âš ï¸ H1 Filter Error: {ex.Message} | Using Neutral Bias");
                    }
                }

                // ğŸ® MODE CONTROLLER
                switch (CurrentMode)
                {
                    case StrategyMode.All:
                        ProcessScalperEntry(h1Bullish, h1Bearish);
                        if (!isFlat) 
                        {
                            ProcessBreakoutEntry(h1Bullish, h1Bearish);
                            ProcessPullbackEntry(h1Bullish, h1Bearish);
                        }
                        break;

                    case StrategyMode.ScalperOnly:
                        ProcessScalperEntry(h1Bullish, h1Bearish);
                        break;

                    case StrategyMode.BreakoutOnly:
                        if (!isFlat) ProcessBreakoutEntry(h1Bullish, h1Bearish);
                        break;

                    case StrategyMode.PullbackOnly:
                        if (!isFlat) ProcessPullbackEntry(h1Bullish, h1Bearish);
                        break;

                    case StrategyMode.ScalperBreakout:
                        ProcessScalperEntry(h1Bullish, h1Bearish);
                        if (!isFlat) ProcessBreakoutEntry(h1Bullish, h1Bearish);
                        break;

                    case StrategyMode.ScalperPullback:
                        ProcessScalperEntry(h1Bullish, h1Bearish);
                        if (!isFlat) ProcessPullbackEntry(h1Bullish, h1Bearish);
                        break;

                    case StrategyMode.BreakoutPullback:
                        if (!isFlat) 
                        {
                            ProcessBreakoutEntry(h1Bullish, h1Bearish);
                            ProcessPullbackEntry(h1Bullish, h1Bearish);
                        }
                        break;
                }
                
                if(ShowPanel) DrawSimpleText();
            }
            catch (Exception ex)
            {
                Print($"âŒ OnBar Error: {ex.Message}");
            }
        }

        protected override void OnTick()
        {
            try
            {
                if (Positions.Count > 0) ManagePositions();
            }
            catch (Exception ex)
            {
                Print($"âŒ OnTick Error: {ex.Message}");
            }
        }

        // =============================================================================
        // ğŸ”¥ POSITION MANAGEMENT WITH EMOJIS
        // =============================================================================
        private void ManagePositions()
        {
            if (_parabolicSAR == null) return;
            double sar = _parabolicSAR.Result.LastValue;
            double atr = _atr.Result.Last(1);
            double pipSize = Symbol.PipSize;

            foreach (var position in Positions.ToList())
            {
                if (position.SymbolName != SymbolName) continue;

                // ğŸ’° PARTIAL TAKE PROFIT 
                if (PartialTpEnabled && !_partiallyClosedPositions.Contains(position.Id.ToString()))
                {
                    double triggerPips = (atr * PartialTpAtrMultiplier) / pipSize;
                    if (position.Pips >= triggerPips)
                    {
                        double volToClose = Symbol.NormalizeVolumeInUnits(position.VolumeInUnits * 0.5, RoundingMode.Down);
                        
                        if (volToClose >= Symbol.VolumeInUnitsMin) 
                        {
                            var closeResult = ClosePosition(position, volToClose);
                            
                            if (closeResult.IsSuccessful) 
                            {
                                Print($"ğŸ’° Partial TP Executed on {position.Label}");
                                _partiallyClosedPositions.Add(position.Id.ToString());
                                
                                // ğŸš¨ Check if position still exists
                                var updatedPosition = Positions.FirstOrDefault(p => p.Id == position.Id);
                                if (updatedPosition != null && updatedPosition.VolumeInUnits > 0)
                                {
                                    double newSL = updatedPosition.TradeType == TradeType.Buy 
                                        ? updatedPosition.EntryPrice + (2 * pipSize) 
                                        : updatedPosition.EntryPrice - (2 * pipSize);
                                    
                                    ModifyPosition(updatedPosition, newSL, updatedPosition.TakeProfit);
                                    Print($"ğŸ›¡ï¸ SL Moved to Breakeven | Remaining: {updatedPosition.VolumeInUnits:F2}");
                                }
                                else
                                {
                                    Print($"âœ… Position Fully Closed by Partial TP");
                                }
                            }
                        }
                        else 
                        {
                            _partiallyClosedPositions.Add(position.Id.ToString());
                            
                            var updatedPosition = Positions.FirstOrDefault(p => p.Id == position.Id);
                            if (updatedPosition != null)
                            {
                                double newSL = updatedPosition.TradeType == TradeType.Buy 
                                    ? updatedPosition.EntryPrice + (2 * pipSize) 
                                    : updatedPosition.EntryPrice - (2 * pipSize);
                                
                                ModifyPosition(updatedPosition, newSL, updatedPosition.TakeProfit);
                                Print($"ğŸ”’ Volume Too Small | SL Moved to Breakeven");
                            }
                        }
                    }
                }

                // ğŸƒ TRAILING STOP 
                if (TrailingSarEnabled && position.VolumeInUnits > 0)
                {
                    double currentSL = position.StopLoss ?? position.EntryPrice;
                    double newSL = currentSL;
                    bool update = false;

                    if (position.TradeType == TradeType.Buy) 
                    {
                        if (sar > currentSL && sar < Symbol.Bid - (2 * pipSize)) 
                        {
                            if (sar - currentSL > pipSize) { newSL = sar; update = true; }
                        }
                    } 
                    else 
                    {
                        if (sar < currentSL && sar > Symbol.Ask + (2 * pipSize)) 
                        {
                            if (currentSL - sar > pipSize) { newSL = sar; update = true; }
                        }
                    }

                    if (update) 
                    {
                        var currentPosition = Positions.FirstOrDefault(p => p.Id == position.Id);
                        if (currentPosition != null)
                        {
                            ModifyPosition(currentPosition, newSL, currentPosition.TakeProfit);
                            Print($"ğŸ“ˆ Trailing SL Updated | New: {newSL:F4}");
                        }
                    }
                }
            }
        }

        // =============================================================================
        // ğŸ¯ STRATEGY ENTRY METHODS
        // =============================================================================

        private void ProcessScalperEntry(bool allowBuy, bool allowSell)
        {
            if (!CanOpenNewPosition("SCALPER")) return;
            
            double currentRsi = _rsiScalper.Result.Last(1);
            double prevRsi = _rsiScalper.Result.Last(2);
            double atr = _atr.Result.Last(1);
            double slPips = (atr * ScalperSlAtr) / Symbol.PipSize;
            double tpPips = (atr * ScalperTpAtr) / Symbol.PipSize;
            double vol = CalculateVolume(slPips, "SCALPER");

            if (prevRsi <= RsiOversold && currentRsi > RsiOversold && allowBuy) 
            {
                if (!HasOppositePosition(TradeType.Buy, "SCALPER")) 
                {
                    var result = ExecuteMarketOrder(TradeType.Buy, SymbolName, vol, "SCALPER", slPips, tpPips);
                    if (result.IsSuccessful) 
                        Print($"âš¡ SCALPER BUY | RSI: {currentRsi:F1} | Vol: {vol:F2} | SL: {slPips:F1}p | TP: {tpPips:F1}p");
                }
            }
            else if (prevRsi >= RsiOverbought && currentRsi < RsiOverbought && allowSell) 
            {
                if (!HasOppositePosition(TradeType.Sell, "SCALPER")) 
                {
                    var result = ExecuteMarketOrder(TradeType.Sell, SymbolName, vol, "SCALPER", slPips, tpPips);
                    if (result.IsSuccessful) 
                        Print($"âš¡ SCALPER SELL | RSI: {currentRsi:F1} | Vol: {vol:F2} | SL: {slPips:F1}p | TP: {tpPips:F1}p");
                }
            }
        }

        private void ProcessBreakoutEntry(bool allowBuy, bool allowSell)
        {
            if (!CanOpenNewPosition("BREAKOUT")) return;
            
            double top = _bollingerBands.Top.Last(1);
            double bottom = _bollingerBands.Bottom.Last(1);
            double close = Bars.ClosePrices.Last(1);
            double open = Bars.OpenPrices.Last(1);
            
            double bandWidth = (top - bottom) / Symbol.PipSize;
            if (bandWidth > BreakoutMaxBandWidth) 
            {
                Print($"ğŸ“ Band Too Wide: {bandWidth:F1}p | Max: {BreakoutMaxBandWidth}p");
                return;
            }
            
            double totalSize = Bars.HighPrices.Last(1) - Bars.LowPrices.Last(1);
            if (totalSize > 0 && (Math.Abs(close - open) / totalSize) < MinBodyRatio) 
            {
                Print($"ğŸ•¯ï¸ Weak Candle Body: {(Math.Abs(close - open) / totalSize):F2} | Min: {MinBodyRatio}");
                return;
            }

            double atr = _atr.Result.Last(1);
            double slPips = (atr * BreakoutSlAtr) / Symbol.PipSize;
            double tpPips = (atr * BreakoutTpAtr) / Symbol.PipSize;
            double vol = CalculateVolume(slPips, "BREAKOUT");

            if (close > top && allowBuy) 
            {
                if (!HasOppositePosition(TradeType.Buy, "BREAKOUT")) 
                {
                    var result = ExecuteMarketOrder(TradeType.Buy, SymbolName, vol, "BREAKOUT", slPips, tpPips);
                    if (result.IsSuccessful) 
                        Print($"ğŸ’¥ BREAKOUT BUY | Above BB: {bandWidth:F1}p | Vol: {vol:F2} | SL: {slPips:F1}p | TP: {tpPips:F1}p");
                }
            }
            else if (close < bottom && allowSell) 
            {
                if (!HasOppositePosition(TradeType.Sell, "BREAKOUT")) 
                {
                    var result = ExecuteMarketOrder(TradeType.Sell, SymbolName, vol, "BREAKOUT", slPips, tpPips);
                    if (result.IsSuccessful) 
                        Print($"ğŸ’¥ BREAKOUT SELL | Below BB: {bandWidth:F1}p | Vol: {vol:F2} | SL: {slPips:F1}p | TP: {tpPips:F1}p");
                }
            }
        }
        
        private void ProcessPullbackEntry(bool allowBuy, bool allowSell)
        {
            if (!CanOpenNewPosition("PULLBACK")) return;
            
            double rsi = _rsiPullback.Result.Last(1);
            bool isUptrend = _trendEmaFast.Result.Last(1) > _trendEmaSlow.Result.Last(1);
            bool isDowntrend = _trendEmaFast.Result.Last(1) < _trendEmaSlow.Result.Last(1);
            double atr = _atr.Result.Last(1);
            double slPips = (atr * PullbackSlAtr) / Symbol.PipSize;
            double tpPips = (atr * PullbackTpAtr) / Symbol.PipSize;
            double vol = CalculateVolume(slPips, "PULLBACK");

            if (isUptrend && rsi < PullbackRsiTrigger && allowBuy) 
            {
                if (!HasOppositePosition(TradeType.Buy, "PULLBACK")) 
                {
                    var result = ExecuteMarketOrder(TradeType.Buy, SymbolName, vol, "PULLBACK", slPips, tpPips);
                    if (result.IsSuccessful) 
                        Print($"ğŸŒŠ PULLBACK BUY | Trend: ğŸŸ¢ UP | RSI: {rsi:F1} | Vol: {vol:F2} | SL: {slPips:F1}p | TP: {tpPips:F1}p");
                }
            }
            else if (isDowntrend && rsi > (100 - PullbackRsiTrigger) && allowSell) 
            {
                if (!HasOppositePosition(TradeType.Sell, "PULLBACK")) 
                {
                    var result = ExecuteMarketOrder(TradeType.Sell, SymbolName, vol, "PULLBACK", slPips, tpPips);
                    if (result.IsSuccessful) 
                        Print($"ğŸŒŠ PULLBACK SELL | Trend: ğŸ”´ DOWN | RSI: {rsi:F1} | Vol: {vol:F2} | SL: {slPips:F1}p | TP: {tpPips:F1}p");
                }
            }
        }

        // =============================================================================
        // ğŸ› ï¸ HELPER METHODS
        // =============================================================================

        private double CalculateVolume(double stopLossPips, string strategy)
        {
            if (stopLossPips <= 0) stopLossPips = 15;
            if (!EnableAutoCompound) return Symbol.QuantityToVolumeInUnits(GetFixedVolume(strategy));
            
            double stratMultiplier = strategy switch { "SCALPER" => 0.8, "BREAKOUT" => 1.0, "PULLBACK" => 1.2, _ => 1.0 };
            
            double systemDampener = CurrentMode switch
            {
                StrategyMode.All => 0.6,
                StrategyMode.ScalperBreakout => 0.8,
                StrategyMode.ScalperPullback => 0.8,
                StrategyMode.BreakoutPullback => 0.8,
                _ => 1.0
            };

            double finalRisk = RiskPerTrade * stratMultiplier * systemDampener;
            double riskAmount = Account.Balance * (finalRisk / 100.0);
            
            double pipValue = Symbol.PipValue;
            if (pipValue == 0) pipValue = Symbol.TickValue; 
            
            double volumeInUnits = riskAmount / (stopLossPips * pipValue);
            
            double normalizedVolume = Symbol.NormalizeVolumeInUnits(volumeInUnits, RoundingMode.Down);
            double minVolume = Symbol.VolumeInUnitsMin;
            double maxVolume = Symbol.VolumeInUnitsMax * 0.1; 
            
            if (normalizedVolume < minVolume) return minVolume;
            if (normalizedVolume > maxVolume) return maxVolume;
            return normalizedVolume;
        }

        private double GetFixedVolume(string strategy)
        {
            return strategy switch
            {
                "SCALPER" => ScalperFixedVolume,
                "BREAKOUT" => BreakoutFixedVolume,
                "PULLBACK" => PullbackFixedVolume,
                _ => 0.01
            };
        }

        private bool HasOppositePosition(TradeType direction, string label)
        {
            var oppositeType = direction == TradeType.Buy ? TradeType.Sell : TradeType.Buy;
            return Positions.Any(p => 
                p.SymbolName == SymbolName && 
                p.TradeType == oppositeType && 
                p.Label == label);
        }

        private bool CanOpenNewPosition(string strategy)
        {
            if (Positions.Count(p => p.Label == strategy) >= 1) 
            {
                Print($"â¸ï¸ {strategy} Already Active | Waiting...");
                return false;
            }
            if (Positions.Count >= 3) 
            {
                Print($"ğŸ›‘ Max Positions Reached ({Positions.Count}/3)");
                return false;
            }
            return true;
        }

        private bool IsTradingAllowed()
        {
            int currentHour = Server.Time.Hour;
            if (currentHour < FIXED_START_HOUR || currentHour >= FIXED_END_HOUR) 
            {
                Print($"ğŸŒ™ Outside Trading Hours | Current: {currentHour:00}:00 | Allowed: {FIXED_START_HOUR:00}-{FIXED_END_HOUR:00}");
                return false;
            }
                
            double currentAtr = _atr.Result.Last(1) / Symbol.PipSize;
            if (currentAtr < MinAtrPips) 
            {
                Print($"ğŸŒŠ Low Volatility | ATR: {currentAtr:F1}p | Min: {MinAtrPips}p");
                return false;
            }
                
            double currentSpread = Symbol.Spread / Symbol.PipSize;
            if (currentSpread > MaxSpread) 
            {
                Print($"ğŸ’¸ Spread Too High | Current: {currentSpread:F1}p | Max: {MaxSpread}p");
                return false;
            }
                
            return true;
        }

        private bool IsMarketTooCrazy() 
        { 
            double currentAtr = _atr.Result.Last(1) / Symbol.PipSize;
            bool tooCrazy = currentAtr > MaxAtrPips;
            if (tooCrazy) Print($"ğŸŒªï¸ Market Too Crazy | ATR: {currentAtr:F1}p | Max: {MaxAtrPips}p");
            return tooCrazy;
        }

        private bool IsMarketFlat()
        {
            double fast = _trendEmaFast.Result.Last(1);
            double slow = _trendEmaSlow.Result.Last(1);
            double diffPips = Math.Abs(fast - slow) / Symbol.PipSize;
            bool isFlat = diffPips < FlatMarketPips;
            if (isFlat) Print($"ğŸ¦€ Flat Market | EMA Diff: {diffPips:F1}p | Threshold: {FlatMarketPips}p");
            return isFlat;
        }

        private void DrawSimpleText()
        {
            string mode = CurrentMode.ToString();
            double equity = Account.Equity;
            double balance = Account.Balance;
            double pl = equity - balance;
            double atrPips = _atr.Result.Last(1) / Symbol.PipSize;
            int positions = Positions.Count;
            
            string plColor = pl >= 0 ? "ğŸŸ¢" : "ğŸ”´";
            string modeIcon = CurrentMode switch
            {
                StrategyMode.ScalperOnly => "âš¡",
                StrategyMode.BreakoutOnly => "ğŸ’¥", 
                StrategyMode.PullbackOnly => "ğŸŒŠ",
                StrategyMode.ScalperBreakout => "âš¡ğŸ’¥",
                StrategyMode.ScalperPullback => "âš¡ğŸŒŠ",
                StrategyMode.BreakoutPullback => "ğŸ’¥ğŸŒŠ",
                _ => "ğŸ¯"
            };
            
            string text = $"TITAN {modeIcon} | {mode} | P/L: {plColor} {pl:F2} | Pos: {positions} | ATR: {atrPips:F1}p | H1: {(EnableTrendFilterH1 ? "âœ…" : "âŒ")}";
            Chart.DrawStaticText("simple_info", text, VerticalAlignment.Top, HorizontalAlignment.Left, 
                               pl >= 0 ? Color.Lime : Color.Orange);
        }

        private void OnPositionOpened(PositionOpenedEventArgs args) 
        { 
            _totalTradesCount++;
            string directionIcon = args.Position.TradeType == TradeType.Buy ? "ğŸŸ¢" : "ğŸ”´";
            Print($"âœ… POSITION OPENED {directionIcon} | {args.Position.Label} | {args.Position.TradeType} | Vol: {args.Position.VolumeInUnits:F2}");
        }

        private void OnPositionClosed(PositionClosedEventArgs args)
        {
            if (_partiallyClosedPositions.Contains(args.Position.Id.ToString())) 
                _partiallyClosedPositions.Remove(args.Position.Id.ToString());
                
            string pnlIcon = args.Position.NetProfit >= 0 ? "ğŸ’°" : "ğŸ’¸";
            Print($"ğŸ”š POSITION CLOSED {pnlIcon} | {args.Position.Label} | P/L: {args.Position.NetProfit:F2}");
        }

        protected override double GetFitness(GetFitnessArgs args)
        {
            double netProfit = args.NetProfit;
            double winRate = args.WinningTrades / (args.TotalTrades + 1.0);
            double drawdown = args.MaxEquityDrawdown;
            double sharpe = args.SharpeRatio;

            double score = (netProfit * 1.0) 
                         - (drawdown * 0.5 * 5.0) 
                         + (winRate * 0.2 * 1000) 
                         + (sharpe * 0.3 * 100);
            return score;
        }

        protected override void OnStop()
        {
            double finalPL = Account.Equity - _initialBalance;
            string performance = finalPL >= 0 ? "ğŸ‰ EXCELLENT" : "ğŸ“‰ NEEDS IMPROVEMENT";
            
            Print($"ğŸ›‘ TITAN FUSION STOPPED");
            Print($"ğŸ“Š FINAL PERFORMANCE: {performance}");
            Print($"ğŸ’° Initial: {_initialBalance:F2} | Final: {Account.Equity:F2} | P/L: {finalPL:F2}");
            Print($"ğŸ“ˆ Total Trades: {_totalTradesCount} | Win Rate: {(_totalTradesCount > 0 ? (Positions.Count(p => p.NetProfit > 0) / (double)_totalTradesCount * 100) : 0):F1}%");
            Print($"ğŸ‘‹ Thank you for trading with Titan Fusion! ğŸš€");
        }
    }
}
